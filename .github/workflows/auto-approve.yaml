name: Mirror public/content → docs-content (create PR) via App

on:
  push:
    branches: [ main ]
    paths:
      - "public/content/**"

env:
  # toggle to enable exact mirror (will delete files in target that are not in source)
  DELETE_AFTER: "false"
  PR_LABELS: "auto-mirror"
  PR_ASSIGNEES: "judson-at-pieces"
  PR_REVIEWERS: ""

jobs:
  mirror-pr:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout source (private repo)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install tools
        run: sudo apt-get update && sudo apt-get install -y rsync curl nodejs npm

      - name: Generate GitHub App installation token
        id: gen_token
        env:
          APP_ID: ${{ secrets.DOCS_MIRROR_APP_ID }}
          APP_PEM: ${{ secrets.DOCS_MIRROR_APP_PRIVATE_KEY }}
          REPO_OWNER: "pieces-app"
        run: |
          npm init -y >/dev/null
          npm install @octokit/auth-app @octokit/rest >/dev/null
          node - <<'NODE'
          const fs = require('fs');
          const { createAppAuth } = require('@octokit/auth-app');
          const { Octokit } = require('@octokit/rest');
          (async () => {
            const appId = Number(process.env.APP_ID);

            let privateKey = process.env.APP_PEM || '';
            if (privateKey.includes('\\n')) privateKey = privateKey.replace(/\\n/g, '\n');
            privateKey = privateKey.replace(/\r/g, '\n');
            if(!appId || !privateKey) { console.error('Missing APP_ID or APP_PEM'); process.exit(1); }
            const appAuth = createAppAuth({ appId, privateKey });
            const appAuthentication = await appAuth({ type: 'app' });
            const oct = new Octokit({ auth: appAuthentication.token });
            const { data: installations } = await oct.request('GET /app/installations');
            const inst = installations.find(i => i.account && i.account.login === process.env.REPO_OWNER);
            if(!inst) { console.error('Installation for org not found. Ensure the app is installed on the org.'); process.exit(1); }
            const installationAuth = createAppAuth({ appId, privateKey, installationId: inst.id });
            const installationAuthentication = await installationAuth({ type: 'installation' });
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `token=${installationAuthentication.token}\n`);
          })().catch(e => { console.error(e); process.exit(1); });
          NODE

      - name: Setup GPG for commit signing
        run: |
          # Generate GPG key for bot
          gpg --batch --generate-key <<EOF
          Key-Type: RSA
          Key-Length: 4096
          Name-Real: pieces-docs-mirror-app
          Name-Email: ci-bot@pieces.app
          Expire-Date: 0
          %no-protection
          EOF
          
          # Get the key ID (don't print it)
          GPG_KEY_ID=$(gpg --list-secret-keys --keyid-format=long --with-colons | awk -F: '/^sec:/ { print $5 }' | head -1)
          echo "GPG_KEY_ID=$GPG_KEY_ID" >> $GITHUB_ENV

      - name: Clone public docs-content using App token
        env:
          APP_TOKEN: ${{ steps.gen_token.outputs.token }}
        run: |
          git clone https://x-access-token:${APP_TOKEN}@github.com/pieces-app/docs-content.git ./mirror
          cd mirror
          git config user.name "pieces-docs-mirror-app"
          git config user.email "ci-bot@pieces.app"
          git config user.signingkey $GPG_KEY_ID
          git config commit.gpgsign true

      - name: Create branch name (output)
        id: set-branch
        run: |
          BRANCH="mirror-sync-${{ github.run_id }}"
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT

      - name: Ensure mirror path exists
        run: |
          mkdir -p ./mirror/public/content

      - name: Sync markdown into branch (sets has_changes output)
        id: sync
        run: |
          RSYNC_DELETE_FLAG=""
          if [ "${{ env.DELETE_AFTER }}" = "true" ]; then RSYNC_DELETE_FLAG="--delete-after"; fi
          rsync -av $RSYNC_DELETE_FLAG public/content/ ./mirror/public/content/
          cd mirror
          if [ -z "$(git status --porcelain)" ]; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
          else
            git add -A
            git commit -S -m "chore(mirror): sync docs from pieces-documentation (run ${{ github.run_id }})"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Push branch to public repo (only if changes)
        if: steps.sync.outputs.has_changes == 'true'
        env:
          APP_TOKEN: ${{ steps.gen_token.outputs.token }}
          BRANCH: ${{ steps.set-branch.outputs.branch }}
        run: |
          cd mirror
          if git ls-remote --exit-code --heads origin "$BRANCH" >/dev/null 2>&1; then
            git checkout -B "$BRANCH"
            git push --force-with-lease https://x-access-token:${APP_TOKEN}@github.com/pieces-app/docs-content.git "$BRANCH"
          else
            git checkout -b "$BRANCH"
            git push https://x-access-token:${APP_TOKEN}@github.com/pieces-app/docs-content.git "$BRANCH"
          fi

      - name: Create Pull Request on docs-content (only if changes)
        if: steps.sync.outputs.has_changes == 'true'
        uses: actions/github-script@v6
        id: create_pr
        env:
          BRANCH: ${{ steps.set-branch.outputs.branch }}
          OWNER: "pieces-app"
          REPO: "docs-content"
          LABELS: ${{ env.PR_LABELS }}
          ASSIGNEES: ${{ env.PR_ASSIGNEES }}
          REVIEWERS: ${{ env.PR_REVIEWERS }}
        with:
          github-token: ${{ steps.gen_token.outputs.token }}
          script: |
            const owner = process.env.OWNER;
            const repo = process.env.REPO;
            const head = process.env.BRANCH;
            const title = `chore(mirror): sync docs from pieces-documentation (${process.env.GITHUB_RUN_ID})`;
            const body = "Automated mirror: this PR contains changes from pieces-documentation/public/content. Review & merge when ready.";
            const { data: pr } = await github.rest.pulls.create({ owner, repo, title, head, base: "main", body });
            core.info(`Created PR #${pr.number}`);
            if (process.env.LABELS) {
              const labels = process.env.LABELS.split(",").map(s => s.trim()).filter(Boolean);
              await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels });
            }
            if (process.env.ASSIGNEES) {
              const assignees = process.env.ASSIGNEES.split(",").map(s => s.trim()).filter(Boolean);
              await github.rest.issues.addAssignees({ owner, repo, issue_number: pr.number, assignees });
            }
            if (process.env.REVIEWERS) {
              const reviewers = process.env.REVIEWERS.split(",").map(s => s.trim()).filter(Boolean);
              await github.rest.pulls.requestReviewers({ owner, repo, pull_number: pr.number, reviewers, team_reviewers: [] });
            }
            core.setOutput("pr_number", pr.number);

      - name: Wait for PR mergeable & enable GitHub auto-merge (safe)
        if: steps.sync.outputs.has_changes == 'true'
        uses: actions/github-script@v6
        env:
          PR_NUMBER: ${{ steps.create_pr.outputs.pr_number }}
        with:
          github-token: ${{ steps.gen_token.outputs.token }}
          script: |
            const owner = 'pieces-app';
            const repo = 'docs-content';
            const prNumber = Number(process.env.PR_NUMBER && process.env.PR_NUMBER.trim() !== '' ? process.env.PR_NUMBER : 0);
            if (!prNumber) throw new Error('PR number not found. Ensure PR creation step sets pr number to output "pr_number".');

            const maxAttempts = 30;
            const waitMs = 5000;
            let decided = false;
            for (let i = 0; i < maxAttempts; i++) {
              const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
              const state = pr.mergeable_state;
              core.info(`PR #${prNumber} mergeable_state=${state} (attempt ${i+1}/${maxAttempts})`);
              if (state === 'clean' || pr.mergeable === true) {
                let nodeId = pr.node_id;
                if (!nodeId) {
                  const prIdQuery = `
                    query($owner:String!, $repo:String!, $num:Int!) {
                      repository(owner:$owner, name:$repo) {
                        pullRequest(number: $num) {
                          id
                        }
                      }
                    }
                  `;
                  let prIdResult;
                  try {
                    prIdResult = await github.graphql(prIdQuery, { owner, repo, num: prNumber });
                  } catch (e) {
                    throw new Error('Failed to fetch PR node ID via GraphQL: ' + e.message);
                  }
                  if (
                    !prIdResult ||
                    !prIdResult.repository ||
                    !prIdResult.repository.pullRequest ||
                    !prIdResult.repository.pullRequest.id
                  ) {
                    throw new Error('Could not retrieve pull request node ID from GraphQL response');
                  }
                  nodeId = prIdResult.repository.pullRequest.id;
                }
                const mutation = `mutation EnableAutoMerge($prId: ID!) { enablePullRequestAutoMerge(input: { pullRequestId: $prId, mergeMethod: MERGE }) { clientMutationId } }`;
                await github.graphql(mutation, { prId: nodeId });
                core.info(`Enabled auto-merge for PR #${prNumber}`);
                decided = true;
                break;
              }
              if (state === 'dirty' || pr.mergeable === false) {
                await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: '⚠️ This PR has merge conflicts and cannot be auto-merged. Please rebase or resolve conflicts so CI can proceed.' });

                try { await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: ['needs-rebase'] }); } catch (e) { core.info('Label add failed: ' + e.message); }
                decided = true;
                break;
              }
              await new Promise(r => setTimeout(r, waitMs));
            }
            if (!decided) {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: '⏱️ Could not determine mergeable state within timeout. Please check this PR manually; auto-merge was not enabled.' });
              try { await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: ['needs-attention'] }); } catch(e) { core.info(`Label add failed: ${e.message}`); }
              core.setOutput('auto_merge_enabled', 'false');
            } else {
              core.setOutput('auto_merge_enabled', 'true');
            }
